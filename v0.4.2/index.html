<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · FLOWMath.jl</title><meta name="title" content="Home · FLOWMath.jl"/><meta property="og:title" content="Home · FLOWMath.jl"/><meta property="twitter:title" content="Home · FLOWMath.jl"/><meta name="description" content="Documentation for FLOWMath.jl."/><meta property="og:description" content="Documentation for FLOWMath.jl."/><meta property="twitter:description" content="Documentation for FLOWMath.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>FLOWMath.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Quadrature"><span>Quadrature</span></a></li><li><a class="tocitem" href="#Root-Finding"><span>Root Finding</span></a></li><li><a class="tocitem" href="#Interpolation"><span>Interpolation</span></a></li><li><a class="tocitem" href="#Smoothing"><span>Smoothing</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/byuflowlab/FLOWMath.jl/blob/{commit}{path}#L{line}" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/byuflowlab/FLOWMath.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="FLOWMath.jl"><a class="docs-heading-anchor" href="#FLOWMath.jl">FLOWMath.jl</a><a id="FLOWMath.jl-1"></a><a class="docs-heading-anchor-permalink" href="#FLOWMath.jl" title="Permalink"></a></h1><p>Examples of the available methods are shown below.  More examples are available in the test suite (/test/runtests.jl)</p><h2 id="Quadrature"><a class="docs-heading-anchor" href="#Quadrature">Quadrature</a><a id="Quadrature-1"></a><a class="docs-heading-anchor-permalink" href="#Quadrature" title="Permalink"></a></h2><h3 id="Trapezoidal-Integration"><a class="docs-heading-anchor" href="#Trapezoidal-Integration">Trapezoidal Integration</a><a id="Trapezoidal-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Trapezoidal-Integration" title="Permalink"></a></h3><p>This is just simple trapezoidal integration using vectors.  <a href="https://github.com/JuliaMath/QuadGK.jl">Gaussian quadrature</a> is much better, but for times when we need to define a mesh for other purposes and cannot use an adaptive method a simple trapezoidal integration fits the bill.</p><pre><code class="language-julia hljs">using ..FLOWMath: trapz

x = range(0.0, stop=pi+1e-15, step=pi/100)
y = sin.(x)
z = trapz(x, y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.9998355038874442</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.trapz" href="#FLOWMath.trapz"><code>FLOWMath.trapz</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trapz(x, y)</code></pre><p>Integrate y w.r.t. x using the trapezoidal method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/quadrature.jl#L3-L7">source</a></section></article><p>There is also <code>cumtrapz</code> which returns the cumulative integral of <code>y</code> with respect to <code>x</code></p><pre><code class="language-julia hljs">using FLOWMath: cumtrapz
x = range(0.0, stop=pi+1e-15, step=pi/100)
y = sin.(x)
z = cumtrapz(x, y)
extrema(z .- ((-cos.(x)) .- (-cos(x[1]))))  # compare to the exact answer -cos(x) - -cos(0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(-0.00016449611255575647, 0.0)</code></pre><p>and a version <code>cumtrapz!</code> that writes the result to the first argument</p><pre><code class="language-julia hljs">using FLOWMath: cumtrapz!
x = range(0.0, stop=pi+1e-15, step=pi/100)
y = sin.(x)
z = similar(y)
cumtrapz!(z, x, y)
extrema(z .- ((-cos.(x)) .- (-cos(x[1]))))  # compare to the exact answer -cos(x) - -cos(0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(-0.00016449611255575647, 0.0)</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.cumtrapz" href="#FLOWMath.cumtrapz"><code>FLOWMath.cumtrapz</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cumtrapz(x, y)</code></pre><p>Cumulatively integrate <code>y</code> w.r.t <code>x</code> using the trapezoidal method, returning an array the same size as <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/quadrature.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.cumtrapz!" href="#FLOWMath.cumtrapz!"><code>FLOWMath.cumtrapz!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cumtrapz!(integral, x, y)</code></pre><p>Cumulatively integrate <code>y</code> w.r.t <code>x</code> using the trapezoidal method, writing the result to <code>integral</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/quadrature.jl#L25-L29">source</a></section></article><h2 id="Root-Finding"><a class="docs-heading-anchor" href="#Root-Finding">Root Finding</a><a id="Root-Finding-1"></a><a class="docs-heading-anchor-permalink" href="#Root-Finding" title="Permalink"></a></h2><h3 id="Brent&#39;s-Method-(1D-functions)"><a class="docs-heading-anchor" href="#Brent&#39;s-Method-(1D-functions)">Brent&#39;s Method (1D functions)</a><a id="Brent&#39;s-Method-(1D-functions)-1"></a><a class="docs-heading-anchor-permalink" href="#Brent&#39;s-Method-(1D-functions)" title="Permalink"></a></h3><p>Brent&#39;s method is an effective 1D root finding method as it combines bracketing methods (bisection) with fast quadratic interpolation.  Thus, you can get near quadratic convergence but with safeguarding.</p><pre><code class="language-julia hljs">using ..FLOWMath: brent

f(x) = x^2 - 1.0
xstar, outputs = brent(f, -2.0, 0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(-1.0, (iter = 9, fcalls = 10, flag = &quot;CONVERGED&quot;))</code></pre><p>The above example shows basic usage.  Additional inputs and outputs are available as described below.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.brent" href="#FLOWMath.brent"><code>FLOWMath.brent</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">brent(f, a, b; args=(), atol=2e-12, rtol=4*eps(), maxiter=100)</code></pre><p>1D root finding using Brent&#39;s method.  Based off the brentq implementation in scipy.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: scalar function, that optionally takes additional arguments</li><li><code>a</code>::Float, b::Float`: bracketing interval for a root - sign changes sign between: (f(a) * f(b) &lt; 0)</li><li><code>args::Tuple</code>: tuple of additional arguments to pass to f</li><li><code>atol::Float</code>: absolute tolerance (positive) for root</li><li><code>rtol::Float</code>: relative tolerance for root</li><li><code>maxiter::Int</code>: maximum number of iterations allowed</li></ul><p><strong>Returns</strong></p><ul><li><code>xstar::Float</code>: a root of f</li><li><code>info::Tuple</code>: A named tuple containing:<ul><li><code>iter::Int</code>: number of iterations</li><li>&#39;fcalls::Int`: number of function calls</li><li>&#39;flag::String`: a convergence/error message.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/roots.jl#L3-L22">source</a></section></article><h2 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h2><h3 id="Akima-Spline"><a class="docs-heading-anchor" href="#Akima-Spline">Akima Spline</a><a id="Akima-Spline-1"></a><a class="docs-heading-anchor-permalink" href="#Akima-Spline" title="Permalink"></a></h3><p>An Akima spline is a 1D spline that avoids overshooting issues common with many other polynomial splines resulting in a more natural curve.  It also only uses local support allowing for more efficient computation.</p><p>Interpolation is perhaps clearest through plotting so we&#39;ll load a plotting package for this examples.</p><pre><code class="language-julia hljs">using ..FLOWMath: akima, Akima, derivative, second_derivative, gradient

x = 0:pi/4:2*pi
y = sin.(x)
xpt = 0:pi/16:2*pi

ypt = akima(x, y, xpt)

figure()
plot(x, y, &quot;o&quot;)
plot(xpt, ypt)</code></pre><p><img src="interp.svg" alt/></p><p>or if you plan to evaluate the spline repeatedly</p><pre><code class="language-julia hljs">spline = Akima(x, y)
ypt = similar(xpt)
ypt .= spline.(xpt) # ypt change in place
ypt = spline(xpt)</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.Akima" href="#FLOWMath.Akima"><code>FLOWMath.Akima</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Akima(xdata, ydata, delta_x=0.0)</code></pre><p>Creates an akima spline at node points: <code>xdata</code>, <code>ydata</code>.  This is a 1D spline that avoids overshooting issues common with many other polynomial splines resulting in a more natural curve.  It also only depends on local points (<code>i-2</code>...<code>i+2</code>) allow for more efficient computation.</p><p><code>delta_x</code> is the half width of a smoothing interval used for the absolute value function.  Set <code>delta_x=0</code> to recover the original akima spline.  The smoothing is only useful if you want to differentiate xdata and ydata.  In many case the nodal points are fixed so this is not needed.</p><p><code>eps</code> is a cutoff used to avoid dividing by zero in the weighting function. Default is <code>1e-30</code> but this could be raised to machine precision in some cases to improve derivatives. (E.g., when the denominator in line 105 is very small.)</p><p>Returns an akima spline object (Akima struct). This function only performs construction of the spline, not evaluation. This is useful if you want to evaluate the same mesh at multiple different conditions. A convenience method exists below to perform both in one shot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/interpolate.jl#L49-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.akima" href="#FLOWMath.akima"><code>FLOWMath.akima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">akima(x, y, xpt, delta=0.0, eps=1e-30)</code></pre><p>A convenience method to perform construction and evaluation of the spline in one step. See docstring for Akima for more details.</p><p><strong>Arguments</strong></p><ul><li><code>x, y::Vector{Float}</code>: the node points</li><li><code>xpt::Vector{Float} or ::Float</code>: the evaluation point(s)</li><li><code>delta_x::Float=0.0</code> : the half width of a smoothing interval used for the absolute</li></ul><p>value function.</p><ul><li><code>eps::Float=1e-30</code> : a cutoff used to avoid dividing by zero in the</li></ul><p>weighting function. Default is <code>1e-30</code> but this could be raised to machine precision in some cases to improve derivatives.</p><p><strong>Returns</strong></p><ul><li><code>ypt::Vector{Float} or ::Float</code>: interpolated value(s) at xpt using akima spline.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/interpolate.jl#L136-L153">source</a></section></article><p>You can also compute the derivative and/or gradient of the spline.</p><pre><code class="language-julia hljs">dydx = derivative(spline, pi/2)
dydx = gradient(spline, xpt)
d2ydx2 = second_derivative(spline, pi/2)</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.derivative" href="#FLOWMath.derivative"><code>FLOWMath.derivative</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">derivative(spline, x)</code></pre><p>Computes the derivative of an Akima spline at x.</p><p><strong>Arguments</strong></p><ul><li><code>spline::Akima}</code>: an Akima spline</li><li><code>x::Float</code>: the evaluation point(s)</li></ul><p><strong>Returns</strong></p><ul><li><code>dydx::Float</code>: derivative at x using akima spline.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/interpolate.jl#L156-L167">source</a></section><section><div><p>derivative of linear interpolation at <code>x::Number</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/interpolate.jl#L246-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.gradient" href="#FLOWMath.gradient"><code>FLOWMath.gradient</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient(spline, x)</code></pre><p>Computes the gradient of a Akima spline at x.</p><p><strong>Arguments</strong></p><ul><li><code>spline::Akima}</code>: an Akima spline</li><li><code>x::Vector{Float}</code>: the evaluation point(s)</li></ul><p><strong>Returns</strong></p><ul><li><code>dydx::Vector{Float}</code>: gradient at x using akima spline.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/interpolate.jl#L200-L211">source</a></section><section><div><p>gradient of linear interpolation at <code>x::Vector</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/interpolate.jl#L256-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.second_derivative" href="#FLOWMath.second_derivative"><code>FLOWMath.second_derivative</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">second_derivative(spline, x)</code></pre><p>Computes the second derivative of an Akima spline at x.</p><p><strong>Arguments</strong></p><ul><li><code>spline::Akima}</code>: an Akima spline</li><li><code>x::Float</code>: the evaluation point(s)</li></ul><p><strong>Returns</strong></p><ul><li><code>d2ydx2::Float</code>: second derivative at x using akima spline.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/interpolate.jl#L178-L189">source</a></section></article><h3 id="Linear-Spline"><a class="docs-heading-anchor" href="#Linear-Spline">Linear Spline</a><a id="Linear-Spline-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Spline" title="Permalink"></a></h3><p>Linear interpolation is straightforward.</p><pre><code class="language-julia hljs">using ..FLOWMath: linear, derivative, gradient

xvec = [1.0, 2.0, 4.0, 5.0]
yvec = [2.0, 3.0, 5.0, 8.0]

y = linear(xvec, yvec, 1.5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2.5</code></pre><p>or we can evaluate at multiple points at once.</p><pre><code class="language-julia hljs">y = linear(xvec, yvec, [1.0, 1.5, 3.0, 4.5, 5.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
 2.0
 2.5
 4.0
 6.5
 8.0</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.linear" href="#FLOWMath.linear"><code>FLOWMath.linear</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear(xdata, ydata, x::Number)</code></pre><p>Linear interpolation.</p><p><strong>Arguments</strong></p><ul><li><code>xdata::Vector{Float64}</code>: x data used in constructing interpolation</li><li><code>ydata::Vector{Float64}</code>: y data used in constructing interpolation</li><li><code>x::Float64</code>: point to evaluate spline at</li></ul><p><strong>Returns</strong></p><ul><li><code>y::Float64</code>: value at x using linear interpolation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/interpolate.jl#L216-L228">source</a></section><section><div><pre><code class="language-julia hljs">linear(xdata, ydata, x::AbstractVector)</code></pre><p>Convenience function to perform linear interpolation at multiple points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/interpolate.jl#L239-L243">source</a></section></article><p>We can also compute derivatives and gradients just as we can for akima.</p><pre><code class="language-julia hljs">dydx = derivative(xvec, yvec, 1.5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0</code></pre><pre><code class="language-julia hljs">dydx = gradient(xvec, yvec, [1.0, 1.5, 3.0, 4.5, 5.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
 1.0
 1.0
 1.0
 3.0
 3.0</code></pre><h3 id="2D/3D/4D-Interpolation-using-Recursive-1D-Interpolation"><a class="docs-heading-anchor" href="#2D/3D/4D-Interpolation-using-Recursive-1D-Interpolation">2D/3D/4D Interpolation using Recursive 1D Interpolation</a><a id="2D/3D/4D-Interpolation-using-Recursive-1D-Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#2D/3D/4D-Interpolation-using-Recursive-1D-Interpolation" title="Permalink"></a></h3><p>The functions <code>interp2d</code>, <code>interp3d</code>, and <code>interp4d</code> are generic and will accept any method that performs 1D interpolation as the first argument.  In the below examples, akima is used.  These examples are based off of examples from Matlab&#39;s interpn documentation.</p><p>2D:</p><pre><code class="language-julia hljs">using ..FLOWMath: interp2d

x = -5.0:5.0
y = -5.0:5.0
z = zeros(11, 11)
for i = 1:11
    for j = 1:11
        v = sqrt(x[i]^2 + y[j]^2) + 1e-15
        z[i, j] = sin(v) / v
    end
end

xpt = range(-5.0, 5.0, length=100)
ypt = range(-5.0, 5.0, length=100)

zpt = interp2d(akima, x, y, z, xpt, ypt)

figure()
contour(xpt, ypt, zpt)</code></pre><p><img src="contour.svg" alt/></p><p>4D:</p><pre><code class="language-julia hljs">using ..FLOWMath: interp4d

x = -1:0.2:1
y = -1:0.2:1
z = -1:0.2:1
t = 0:2:10.0

nx = length(x)
ny = length(y)
nz = length(z)
nt = length(t)

f = Array{typeof(x[1])}(undef, nx, ny, nz, nt)

for i = 1:nx
    for j = 1:ny
        for k = 1:nz
            for l = 1:nt
                f[i, j, k, l] = t[l]*exp(-x[i]^2 - y[j]^2 - z[k]^2)
            end
        end
    end
end

xpt = -1:0.05:1
ypt = -1:0.08:1
zpt = -1:0.05:1
tpt = 0:0.5:10.0

fpt = interp4d(akima, x, y, z, t, f, xpt, ypt, zpt, tpt)</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.interp2d" href="#FLOWMath.interp2d"><code>FLOWMath.interp2d</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>interp2d(interp1d, xdata, ydata, fdata, xpt, ypt)</p><p>2D interpolation using recursive 1D interpolation.  This approach is likely less efficient than a more direct 2D interpolation method, especially one you can create separate creation from evaluation, but it is generalizable to any spline approach and any dimension.</p><p><strong>Arguments</strong></p><ul><li><code>interp1d</code>: any spline function of form: ypt = interp1d(xdata, ydata, xpt) where data are the known   data(node) points and pt are the points where you want to evaluate the spline at.</li><li><code>xdata::Vector{Float}</code>, <code>ydata::Vector{Float}</code>: Define the 2D grid</li><li><code>fdata::Matrix{Float}</code>: where fdata[i, j] is the function value at xdata[i], ydata[j]</li><li><code>xpt::Vector{Float}</code>, <code>ypt::Vector{Float}</code>: the locations where you want to evaluate the spline</li></ul><p><strong>Returns</strong></p><ul><li><code>fhat::Matrix{Float}</code>: where fhat[i, j] is the estimate function value at xpt[i], ypt[j]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/interpolate.jl#L263-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.interp3d" href="#FLOWMath.interp3d"><code>FLOWMath.interp3d</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interp3d(interp1d, xdata, ydata, zdata, fdata, xpt, ypt, zpt)</code></pre><p>Same as interp2d, except in three dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/interpolate.jl#L300-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.interp4d" href="#FLOWMath.interp4d"><code>FLOWMath.interp4d</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interp4d(interp1d, xdata, ydata, zdata, fdata, xpt, ypt, zpt)</code></pre><p>Same as interp3d, except in four dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/interpolate.jl#L327-L331">source</a></section></article><h2 id="Smoothing"><a class="docs-heading-anchor" href="#Smoothing">Smoothing</a><a id="Smoothing-1"></a><a class="docs-heading-anchor-permalink" href="#Smoothing" title="Permalink"></a></h2><h3 id="Absolute-value"><a class="docs-heading-anchor" href="#Absolute-value">Absolute value</a><a id="Absolute-value-1"></a><a class="docs-heading-anchor-permalink" href="#Absolute-value" title="Permalink"></a></h3><p>The absolute value function is not differentiable at x = 0.  The below function smoothly adds a small quadratic function in place of the cusp with a half-width given by <code>delta_x</code>.  This small rounding at the bottom can prevent numerical issues with gradient-based optimization.</p><pre><code class="language-julia hljs">using ..FLOWMath: abs_smooth

x = range(-2.0, 2.0, length=100)
delta_x = 0.1

y = abs_smooth.(x, delta_x)

figure()
plot(x, y)</code></pre><p><img src="abs.svg" alt/></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.abs_smooth" href="#FLOWMath.abs_smooth"><code>FLOWMath.abs_smooth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abs_smooth(x, delta_x)</code></pre><p>Smooth out the absolute value function with a quadratic interval. delta_x is the half width of the smoothing interval. Typically usage is with gradient-based optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/smooth.jl#L3-L9">source</a></section></article><h3 id="Kreisselmeier-Steinhauser-Constraint-Aggregation-Function"><a class="docs-heading-anchor" href="#Kreisselmeier-Steinhauser-Constraint-Aggregation-Function">Kreisselmeier-Steinhauser Constraint Aggregation Function</a><a id="Kreisselmeier-Steinhauser-Constraint-Aggregation-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Kreisselmeier-Steinhauser-Constraint-Aggregation-Function" title="Permalink"></a></h3><p>The Kreisselmeier-Steinhauser (KS) function is often used with constrained gradient-based optimization problems to smoothly aggregate an arbitrary number of constraints into a single constraint.  It may also be used as a smooth approximation of the maximum function (or minimum function).  A salient feature of this function is that it is guaranteed to overestimate the maximum function (or underestimate the minimum function).  This feature of the function can be used to ensure that the resulting constraint is conservative.</p><p>We provide two implementations of this function: <code>ksmax</code> and <code>ksmin</code>.  <code>ksmax</code> and <code>ksmin</code> may be used to smoothly approximate the maximum and minimum functions, respectively.  Both functions take the optional parameter <code>hardness</code> that controls the smoothness of the resulting function.  As <code>hardness</code> increases the function more and more closely approximates the maximum (or minimum) function.</p><pre><code class="language-julia hljs">using ..FLOWMath: ksmax, ksmin

x = [1.2, 0.0, 0.5]
hardness = 100
max_x = ksmax(x, hardness)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.2</code></pre><pre><code class="language-julia hljs">min_x = ksmin(x, hardness)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-0.0</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.ksmax" href="#FLOWMath.ksmax"><code>FLOWMath.ksmax</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ksmax(x, hardness=50)</code></pre><p>Kreisselmeier–Steinhauser constraint aggregation function.  In the limit as <code>hardness</code> goes to infinity the maximum function is returned. Is mathematically guaranteed to overestimate the maximum function, i.e. <code>maximum(x) &lt;= ksmax(x, hardness)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/smooth.jl#L18-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.ksmin" href="#FLOWMath.ksmin"><code>FLOWMath.ksmin</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ksmin(x, hardness=50)</code></pre><p>Kreisselmeier–Steinhauser constraint aggregation function.  In the limit as <code>hardness</code> goes to infinity the minimum function is returned. Is mathematically guaranteed to underestimate the minimum function, i.e. <code>minimum(x) &lt;= ksmin(x, hardness)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/smooth.jl#L30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.ksmax_adaptive" href="#FLOWMath.ksmax_adaptive"><code>FLOWMath.ksmax_adaptive</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ksmax_adaptive(x, hardness=50; tol=1e-6, smoothing_fraction=0.1)</code></pre><p>Kreisselmeier–Steinhauser constraint aggregation function using the adaptive hardness proposed by Poon and Martins in &quot;An adaptive approach to constraint aggregation using adjoint sensitivity analysis&quot;.  This implementation uses Newton&#39;s method rather than the secant method for increasing hardness values. Some blending is also used to ensure that result is C1 continuous. <code>smoothing_fraction</code> controls the smoothness of this blending.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/smooth.jl#L39-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.ksmin_adaptive" href="#FLOWMath.ksmin_adaptive"><code>FLOWMath.ksmin_adaptive</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ksmin_adaptive(x, hardness=50; tol=1e-6, smoothing_fraction=0.1)</code></pre><p>Kreisselmeier–Steinhauser constraint aggregation function using the adaptive hardness proposed by Poon and Martins in &quot;An adaptive approach to constraint aggregation using adjoint sensitivity analysis&quot;.  This implementation uses Newton&#39;s method rather than the secant method for increasing hardness values. Some blending is also used to ensure that result is C1 continuous. <code>smoothing_fraction</code> controls the smoothness of this blending.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/smooth.jl#L65-L74">source</a></section></article><h3 id="Blending-functions-using-the-sigmoid-function"><a class="docs-heading-anchor" href="#Blending-functions-using-the-sigmoid-function">Blending functions using the sigmoid function</a><a id="Blending-functions-using-the-sigmoid-function-1"></a><a class="docs-heading-anchor-permalink" href="#Blending-functions-using-the-sigmoid-function" title="Permalink"></a></h3><p>The sigmoid function may be used to smoothly blend the results of two continuous one-dimensional functions.  The method implemented in this package uses a user-specified transition location (<code>xt</code>) and scales the input of the sigmoid function using the input <code>hardness</code> in order to adjust the smoothness of the transition between the two functions.</p><pre><code class="language-julia hljs">using ..FLOWMath: sigmoid_blend

x = 0.1
f1x = x
f2x = x^2
xt = 0.0
hardness = 25
y = sigmoid_blend(f1x, f2x, x, xt, hardness)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.016827236201911913</code></pre><p><code>sigmoid_blend</code> can also be used with vector inputs using broadcasting.</p><pre><code class="language-julia hljs">x = -0.25:0.001:0.25
f1x = x
f2x = x.^2
xt = 0.0
hardness = 25
y = sigmoid_blend.(f1x, f2x, x, xt, hardness)

figure()
plot(x, f1x)
plot(x, f2x)
plot(x, y)
legend([&quot;f1(x)&quot;,&quot;f2(x)&quot;,&quot;sigmoid&quot;])</code></pre><p><img src="sigmoid.svg" alt/></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.sigmoid_blend" href="#FLOWMath.sigmoid_blend"><code>FLOWMath.sigmoid_blend</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sigmoid_blend(f1x, f2x, x, xt, hardness=50)</code></pre><p>Smoothly transitions the results of functions f1 and f2 using the sigmoid function, with the transition between the functions located at <code>xt</code>. <code>hardness</code> controls the sharpness of the transition between the two functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/smooth.jl#L128-L134">source</a></section><section><div><pre><code class="language-julia hljs">sigmoid_blend(fx::Tuple, xt::Tuple, x, hardness=50)</code></pre><p>Smoothly transitions the results of the functions in <code>fx</code> using the sigmoid function, with the transition between the functions at the locations in <code>xt</code>. <code>hardness</code> controls the sharpness of the transition between the functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/smooth.jl#L140-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.sigmoid" href="#FLOWMath.sigmoid"><code>FLOWMath.sigmoid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sigmoid(x)</code></pre><p>Sigmoid function, implemented with branching to avoid NaNs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/smooth.jl#L113-L117">source</a></section></article><h3 id="Blending-functions-using-cubic-or-quintic-polynomials"><a class="docs-heading-anchor" href="#Blending-functions-using-cubic-or-quintic-polynomials">Blending functions using cubic or quintic polynomials</a><a id="Blending-functions-using-cubic-or-quintic-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Blending-functions-using-cubic-or-quintic-polynomials" title="Permalink"></a></h3><p>Cubic or quintic polynomials can also be used to construct a piecewise function that smoothly blends two functions.  The advantage of this approach compared to <code>sigmoid_blend</code> is that the blending can be restricted to a small interval defined by the half-width <code>delta_x</code>.  The disadvantage of this approach is that the resulting function is only C1 continuous when <code>cubic_blend</code> is used, and C2 continuous when <code>quintic_blend</code> is used.  The method implemented in this package uses a user-specified transition location (<code>xt</code>).  The smoothness of the transition between the two functions can be adjusted by modifying <code>delta_x</code>, which is the half-width of the transition interval.</p><pre><code class="language-julia hljs">using ..FLOWMath: cubic_blend, quintic_blend

x = 0.05
f1x = x
f2x = x^2
xt = 0.0
delta_x = 0.1
y1 = cubic_blend(f1x, f2x, x, xt, delta_x)
y2 = quintic_blend(f1x, f2x, x, xt, delta_x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.007416992187499999</code></pre><p><code>cubic_blend</code> and <code>quintic_blend</code> can also be used with vector inputs using broadcasting.</p><pre><code class="language-julia hljs">x = -0.25:0.001:0.25
f1x = x
f2x = x.^2
xt = 0.0
delta_x = 0.1
y1 = cubic_blend.(f1x, f2x, x, xt, delta_x)
y2 = quintic_blend.(f1x, f2x, x, xt, delta_x)

figure()
plot(x, f1x)
plot(x, f2x)
plot(x, y1)
plot(x, y2)
legend([&quot;f1(x)&quot;,&quot;f2(x)&quot;,&quot;cubic&quot;, &quot;quintic&quot;])</code></pre><p><img src="cubic.svg" alt/></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.cubic_blend" href="#FLOWMath.cubic_blend"><code>FLOWMath.cubic_blend</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cubic_blend(f1x, f2x, x, xt, delta_x)</code></pre><p>Smoothly transitions the results of functions f1 and f2 using a cubic polynomial, with the transition between the functions located at <code>xt</code>. delta_x is the half width of the smoothing interval.  The resulting function is C1 continuous.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/smooth.jl#L157-L163">source</a></section><section><div><pre><code class="language-julia hljs">cubic_blend(fx::Tuple, xt::Tuple, x, delta_x)</code></pre><p>Smoothly transitions the results of the functions in <code>fx</code> using cubic polynomials, with the transition between the functions at the locations in <code>xt</code>. <code>delta_x</code> is the half width of the smoothing interval.  The resulting function is C1 continuous</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/smooth.jl#L176-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.quintic_blend" href="#FLOWMath.quintic_blend"><code>FLOWMath.quintic_blend</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quintic_blend(f1x, f2x, x, xt, delta_x)</code></pre><p>Smoothly transitions the results of functions f1 and f2 using a quintic polynomial, with the transition between the functions located at <code>xt</code>. delta_x is the half width of the smoothing interval.  The resulting function is C2 continuous.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/smooth.jl#L193-L199">source</a></section><section><div><pre><code class="language-julia hljs">quintic_blend(fx::Tuple, xt::Tuple, x, delta_x)</code></pre><p>Smoothly transitions the results of the functions in <code>fx</code> using quintic polynomials, with the transition between the functions at the locations in <code>xt</code>. <code>delta_x</code> is the half width of the smoothing interval.  The resulting function is C2 continuous</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/smooth.jl#L212-L218">source</a></section></article><h3 id="Complex-step-safe-functions"><a class="docs-heading-anchor" href="#Complex-step-safe-functions">Complex-step safe functions</a><a id="Complex-step-safe-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-step-safe-functions" title="Permalink"></a></h3><p>The <a href="https://doi.org/10.1145/838250.838251">complex-step derivative approximation</a> can be used to easily and accurately approximate first derivatives.  This is particularly useful to verify derivatives computed via other means like AD (in contrast to comparing against finite differencing, which suffers from inaccuracies). However, the function <code>f</code> one wishes to differentiate must be composed of functions that are compatible with the method. Most elementary functions are, but a few common ones are not:</p><ul><li><code>abs</code></li><li><code>abs2</code></li><li><code>norm</code></li><li><code>dot</code></li><li>the two argument form of <code>atan</code> (often called <code>atan2</code> or <code>arctan2</code> in other languages)</li></ul><p>FLOWMath provides complex-step safe versions of these functions. These functions use Julia&#39;s multiple dispatch to fall back on the standard implementations when given real arguments, and so shouldn&#39;t impose any performance penalty when not used with the complex step method.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.abs_cs_safe" href="#FLOWMath.abs_cs_safe"><code>FLOWMath.abs_cs_safe</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abs_cs_safe(x)</code></pre><p>Calculate the absolute value of <code>x</code> in a manner compatible with the complex-step derivative approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/cs_safe.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.abs2_cs_safe" href="#FLOWMath.abs2_cs_safe"><code>FLOWMath.abs2_cs_safe</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abs2_cs_safe(x)</code></pre><p>Calculate the squared absolute value of <code>x</code> in a manner compatible with the complex-step derivative approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/cs_safe.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.norm_cs_safe" href="#FLOWMath.norm_cs_safe"><code>FLOWMath.norm_cs_safe</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">norm_cs_safe(x, p)</code></pre><p>Calculate the <code>p</code>-norm value of iterable <code>x</code> in a manner compatible with the complex-step derivative approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/cs_safe.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.dot_cs_safe" href="#FLOWMath.dot_cs_safe"><code>FLOWMath.dot_cs_safe</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot_cs_safe(a, b)</code></pre><p>Calculate the dot product of vectors <code>a</code> and <code>b</code> in a manner compatible with the complex-step derivative approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/cs_safe.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLOWMath.atan_cs_safe" href="#FLOWMath.atan_cs_safe"><code>FLOWMath.atan_cs_safe</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">atan_cs_safe(y, x)</code></pre><p>Calculate the two-argument arctangent function in a manner compatible with the complex-step derivative approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWMath.jl/blob/6b4b258ae75783750d679f87b8a090f93d18618b/src/cs_safe.jl#L65-L69">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 30 January 2025 19:26">Thursday 30 January 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
